Титул (10 сек)
-----

Здравствуйте, меня зовут Мария Куклина, и я хотела бы представить
Вам свою работу
"Применение метода суперкомпиляции для специализации реляционных программ".

Реляционное программирование (20 сек) (30 сек)
-----------------------------------------------

Реляционное программирование -- это вид
декларативного программирования, в котором
программы определяются как наборы математических отношений.
Оно является историческим развитием логического программирования.

Система для реляционного программирования может не только 
проверить, выполняется ли отношение на данных аргументах, 
но и найти возможные значения переменных, при которых отношение верно.

miniKanren (20 сек) (50 сек)
----------------------------

Самый известный представитель реляционной парадигмы --
это miniKanren, встраиваемый предметно-ориентированный язык, 
представленный 
как набор операторов, которые нужно реализовать в произвольном 
хостовом языке. 

miniKanren отличает от языков логического программирования, таких
как Prolog, полнота поиска ответов: гарантируется, что 
каждый ответ будет со временем найден.

Постановка проблемы (20 сек) (1 мин 10 сек)
-------------------

Часто наиболее простой способ записи отношения не является самым 
эффективным.

Также практически всегда производительность запросов сильно зависит от
того, какие компоненты отношения нужно определить. 

// В частности, при задании функциональных отношений как сопоставления 
// выходов входам задача поиска входа по известному выходу практически 
// всегда  выполняется медленне прямого запуска.

Специализация (30 сек) (1 мин 40 сек)
-------------

Одно возможных решений --- применить специализацию.

Специализация -- это техника автоматической оптимизации программ,
при которой на основе программы и её частичного входа
порождается новая, более оптимальная программа, которая сохраняет семантику
исходной.

Основной метод специализации для логических языков --- это частичная дедукция.
Наиболее проработанный её подвид --- это конъюктивная частичная
дедукция. Уже существует её реализация для miniKanren, однако
результаты его применения нестабильные:
в некоторых случаях производительность значительно улучшается,
но в других может существенно ухудшиться.

Суперкомпиляция (35 сек) (2 мин 15 сек)
---------------

Другой подход, который можно применить для специализации -- это 
суперкомпиляция, 
техника автоматической трансформации и анализа программ,
при которой программа символьно исполняется с сохранением истории 
вычислений, на основе которой принимаются решения об оптимизации.

Суперкомпиляция успешно применяется для функциональных языков и даёт
хорошие результаты, но для логических языков не очень хорошо 
проработана, и самое близкое, что существует --- это 
полуавтоматическая суперкомпиляция для
Prolog, требующая ручной разметки программ и заточенная под 
структуру Prolog'а.

При этом некоторые исследователи считают применение суперкомпиляции
перспективным направлением для оптимизации логических программ, и 
их доводы также применимы к реляционным.

Цели и задачи (15 сек) (2 мин 30 сек)
-------------

Таким образом, моя цель --- улучшить результаты специализации программ
на miniKanren с помощью применения метода суперкомпиляции.

Для этого требуется реализовать суперкомпилятор и рассмотреть
и реализовать возможные его улучшения 
для повышения качества специализации.

Суперкомпиляция для miniKanren (20 сек) (2 мин 50 сек)
------------------------------

На слайде представлена схема алгоритма суперкомпиляции.

Реализованный суперкомпилятор основан на библиотеке для специализации,
которая предоставила ряд полезных алгоритмов. Мною были реализованы 
модули развёртки, 
свёртки, и выявления оптимальной программы --- резидуализации --- 
по построенному
в процессе прогонки графу с обобщённой историей вычислений, 
а также я объединила эти модули в суперкомпилятор.

Особенности (20 сек) (3 мин 10 сек)
-----------

Для miniKanren, в отличие от того же Prolog,
семантика языка допускает несколько способов сделать
шаг символьного исполнения, выполняемый на этапе развёртки.
Выбор конкретного
шага определяет множество рассматриваемых состояний,
в которые может перейти программа.

Для первой реализации суперкомпилятора был рассмотрен шаг развёртки,
при котором анализируются все возможные состояния.

Результаты задачи (10 сек) (3 мин 20 сек)
-----------------------------------------

В результате были разработаны и реализованы алгоритмы суперкомпиляции
и резидуализации миниКанрена.

Улучшение суперкомпиляции (1 мин) (4 мин 20 сек)
-------------------------

Классический алгоритм суперкомпиляции
не заточен под практическое применение и подразумевает
использование дополнительных оптимизаций.

Части повторых вычислений удалось избежать путём применения
кэширования.

Классическое обобщение может приводить к избыточным
вычислениям, поэтому были рассмотраны две возможности
его изменения:
первый описан в статьях по суперкомпиляции, 
а второй, специфичный для миниКанрена, придумала сама.

В то же время, реализованная изначально стратегия развёртки хотя и 
покрывает все возможные состояния, но приводит к тому,
что программы начинают сильно ветвиться, что ухудшает 
производительность  как суперкомпиляции, так и вычисления, 
в силу чего имеет смысл рассмотреть иные стратегии развёртки.

Дополнительно я расширила библиотеку специализации поддержкой
оператора miniKanren, 
который позволяет предварительно прервать  вычисления,
если оказалось, что некоторые две сущности равны, хотя не должны быть.
Также реализовала поддержку информации о неравенствах
в суперкомпиляторе.


Результаты (15 сек) (4 мин 45 сек)
----------

В итоге были реализованы предложенные вариации и
рассмотрен ряд стратегий вычисления.

Тестирование (35 сек) (5 мин 20 сек)
------------

В качестве конкретной реализации miniKanren был взят Оканрен.
Для сравнений использовались реализация CPD для miniKanren и
наиболее проработанная реализация CPD для Prolog -- ECCE.

Для работы с последней было необходимо транслировать программы 
из miniKanren в Prolog и обратно.
Различие реализаций лишь в том, что специализация ECCE всё же
заточена под методы исполнения Prolog, однако более проработана.

Замеры происходили на обычном ноутбуке.

Тестирование происходило по сценарию:
* суперкомпиляция программы
* трансляция результата в OCanren
* определение времени исполнения программы на разных входных данных
* сравнение результатов


Тестирование. Программы (25 сек) (5 мин 45 сек)
------------------------

Для демонстрации результатов был выбран следующий набор программ:
* алгоритм сортировки,
  с помощью которого мы сортируем списки фиксированной длины;

* проверка принадлежности пути графу,
  с помощью которого мы ищем произвольный путь фиксированной 
  длины в данном графе;

* реляционный интерпретатор формул логики высказываний,
  с помощью которого 
  мы ищем все выполнимые формулы
  с заданным количеством переменных;
 
* реляционный интерпретатор лямбда-выражений,
  с помощью которого 
  мы ищем термы определённого вида.

Тестирование. Сравнение модификаций (30 сек) (6 мин 15 сек)
------------------------------------

В рамках работы были рассмотрены пять модификаций базового
алгоритма суперкомпиляции с восмью вариантами стратегий развёртки:
одна модификация была описана в статьях,
две модификации были предложены мной, ещё две --- комбинация
этих модификаций.

По результатам тестирования было выявлено, что 
предложенные мной модификаци показывали значительное
улучшение производительности для определённого класса
программ, но проигрывали на остальных. В среднем 
лучшей оказалась модификация из статей.

Операция неравенства значительно улучшила производительность
на рассмотренных примерах.

Тестирование. Сравнение суперкомпилятора (15 сек) (6 мин 30 сек)
----------------------------------------

На слайде представлены результаты выполнения программ.

Несложно отметить, что суперкомпиляция во всех рассмотренных
случаях даёт значительный прирост производительности 
относительно оригинальной
программы, а частичной дедукции несущественно уступает
на ряде программ.

Результаты работы (20 сек) (6 мин 50 сек)
-----------------

В итоге был реализован и протестирован суперкомпилятор для miniKanren,
реализованы и изучены возможные модификации алгоритма и стратегии
вычислений. Помимо этого, добавлены ограничение на неравенства
и исправлен ряд серьёзных багов, что способствует дальнейшим
исследованиям в области специализации miniKanren.
