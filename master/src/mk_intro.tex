% Byrd
{\it miniKanren} -- семейство встраеваемых предметно-ориентированных языков, специально спроектированное для
реляционного программирования~\cite{byrdMK}.

Основная реализация miniKanren написана на языке Scheme~\cite{reasonedSchemer}, однако существует множество встраиваний
в ряд других языков, в том числе Clojure, Racket, OCaml, Haskell и другие.

miniKanren предоставляет набор базовых конструкций: унификация ($\equiv$),
конъюнкция $(\land)$, дизъюнкция $(\lor)$, введение свежей переменной (fresh), вызов реляционного отношения,
--- представляющий ядро языка, и разнообразные расширения, к примеру, оператор неэквивалентности
\origin{disequality constraint} или нечистые операторы, предоставляющие функциональность
отсечения \origin{cut} из Prolog.

Классический пример --- программа конкатенации двух списков --- указан на рисунке~\ref{lst:appendo}.

\begin{figure}[h!]
$\text{append}^o$ X Y R = \\
X $\equiv$ [] $\land$ Y $\equiv$ R $\lor$ \\
fresh (H X' R') \\
\ \ (X $\equiv$ H :: X') $\land$ \\
\ \ (R $\equiv$ H :: R') $\land$ \\
\ \ appendo X' Y R'
\label{list:appendo}
\caption{Пример программы на miniKanren (:: --- конструктор списка)}
\end{figure}

Список R является конкатенацией списков X и Y в случае, когда список X пуст, а Y равен R, либо
когда X и R раскладываются на голову и хвост, а их хвосты состоят в отношении конкатенации с Y.

Для выполнения конкатенации над списками необходимо сформировать \emph{запрос} (или \emph{цель}).
В запросе в аргументах указываются либо замкнутые термы, либо термы со свободными переменными. Результатом
выполнения является список подстановок для свободных переменных, при которых отношение выполняется
(когда свободных переменных нет, подстановка, соответственно, пустая).

% Реализации miniKanren используют алгоритм унификации с проверкой вхождения \origin{occurs check},
% что приводит к корректности порождаемых подстановок~\cite{unifRev}. 
% Реализации miniKanren используют особый порядок обхода в поисках ответов, основанный на поиске
% в глубину, при котором в особых сл

В определение miniKanren входит особый алгоритм поиска ответов --- чередующийся поиск \origin{interleaving search},
основанный на поиске в глубину, который рассматривает всё пространство поиска и гарантирует,
что если существует ответ, то алгоритм его предоставит за конечное время.
Для сравнения, обычный поиск в глубину, используемый в классическом Prolog, может зациклиться
перед тем, как предоставить все ответы. Это свойство чередующегося поиска определяет, вместе
с отсутствием нечистых расширений, реляционность miniKanren. 

% Применимость
Хотя miniKanren уже применяется в индустрии для поиска лечения редких генетических
заболеваний в точной медицине\cite{medMK},
на данном этапе своего развития используется в основном в исследовательских целях.

Одно из интересных применений miniKanren --- {\it реляционные интерпретаторы}.

Для языка $L$ его интерпретатор -- это функция $\text{eval}_L$, которая принимает
на вход программу $p_L$ на этом языке, её вход $i$ и возвращает некоторый выход $o$:
\[ \text{eval}_L (p_L, i) = \llbracket p_L \rrbracket (i) = o, \]

где $\llbracket \bullet \rrbracket $ --- семантика языка L.
Тогда в miniKanren интерпретатор описывается отношением $\text{eval}^o_L(p_L, i, o)$.
При запуске такого отношения на разном наборе аргументов можно добиться интересных эффектов:
\begin{itemize}
\item по программе $p_L$ и выходу $o$ искать возможные входы $i$ (запуск программы в обратном направлении);
  %: $\text{eval}^o(\text{add}, I, 3)$
\item решать задачи поиска по задаче распознавания~\cite{lozov};
\item генерировать программы по заданной спецификации входа $i$ и выхода $o$
(техника программирования по примерам)\cite{unifiedMK}.
\end{itemize}

\todo{проблемы miniKanren: долгое вычисления сложных алгоритмов, долгие вычисления в обратном направлении.}

Одно из возможных решения проблем производительности --- специализация.
