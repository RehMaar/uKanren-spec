{\bf Специализация} --- это метод автоматической оптимизации программ,
при которой из программы удаляются избыточные вычисления,
возможно, на основе информации о вхоных аргументах программы~\cite{jones}.

% Специализацию программ также называют \emph{частичными} или
% \emph{смешанными вычислениями}\cite{jones}.

{\it Специализатор} $\text{spec}_L$ языка $L$ принимает на вход программу $p_L$ и часть известного входа этой
программы $i_s$ (\emph{статических} данных) и генерирует новую программу $\hat{p}_L$, которая ведёт себя на оставшемся
входе $i_d$ (\emph{динамических} данных) также, как и оригинальная программа (формула~\ref{eq:spec}).

\begin{equation}
  \llbracket \text{spec}_L(p_L, i_s) \rrbracket (i_d) \equiv \hat{p}_L (i_d) \equiv \llbracket p_L \rrbracket (i_s, i_d)
\label{eq:spec}
\end{equation}

% Эффекты специализаторов
Специализатор производит все вычисления, зависимые от статических данных,
протягивание констант, инлайнгинг и другие.

Одно из интересных теоретических применений специализации --- это
\emph{проекции Футамуры}~\cite{futamura}. Процесс специализации интерпретатора
на программу на языке $L$ $\text{spec}_L(\text{eval}_L, p_L)$
порождает \emph{скомплированную} программу $\hat{p}_L$, а процесс специализации
специализатора на интерпретатор языка $L$
$\text{spec}_{L''}(\text{spec}_{L'}, \text{eval}_L)$, в свою очередь,
порождает \emph{компилятор}. Это первая и вторая проекции Футамуры
соответственно. Однако реализация специализаторов, которые бы не оставляли
в порождаемой программе следы интерпретации, сложная и труднодостижимая
задача~\cite{jones}.

Специализация разделяется на два больших класса: \emph{online} и \emph{offline}
алгоритмы:
\begin{itemize}
\item offline-cпециализаторы --- это двухфазовые алгоритмы специализации,
     в первой фазе которого происходит разметка исхного кода, к примеру,
     с помощью анализа времени связывания~\cite{jones}, и во второй
     фазе --- непосредственно во время специализации --- \emph{только}
     на основе полученной разметки принимаются решения об оптимизации;
\item online-специализаторы, напротив, принимают решения о специализации
      на лету и могут произвести вычисления, для которых offline сгенеировал
      бы код.
\end{itemize}

\todo{Связывающие слова.}

\subsubsection{Специализация логических языков}

{\bf Частичная дедукция} --- класс методов специализации логический языков,
основанных на построении деревьев вывода, которые отражают процесс вывода методом
резолюций, и анализе отдельно взятых атомов логических формул~\cite{advanced}.

Реализации методов частичной дедукции успешно применяются для
Prolog~\cite{prologPE},
в частности, система offline частичной дедукции LOGEN
показывает хорошие результаты при специализации интерпретаторов и
для некоторых интерпретаторов достигает для генерируемых программ
отсутствие накладных расходов на интерпретацию,
однако требует ручной модификации разметки~\cite{offlinePD}.

\Cpd --- одно из расширений метода частичной дедукции, отличительная
особенность которой состоит в том, что конъюнкции рассматриваются как
единая сущность наравне с атомами~\cite{cpd}. С помощью \forcpd
возможно добиться различных оптимизационных эффектов, среди которых
выделяется дефорестация и таплинг. Это наиболее проработанный и
мощный метод частичной дедукции.

Реализация методов частичной дедукции, включая конъюнктивную частичную дедукцию, для Prolog
представлена в виде системы ECCE~\cite{ecce}.

В работе~\cite{lozov} представляется адаптация конъюнктивной частичной дедукции для miniKanren.
Реализация добивается существенного роста производительности, однако,
как будет показано в разделе~\ref{src:testing}, в силу особенностей метода и его
направленности на Prolog, нестабильно даёт хорошие результаты и
в некоторых случаях может затормозить исполнение программы.

\subsubsection{Методы суперкомпиляции}
\input{review/scomp.tex}
