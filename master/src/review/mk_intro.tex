% Byrd
{\it miniKanren} -- семейство встраеваемых предметно-ориентированных языков, специально спроектированное для
реляционного программирования~\cite{byrdMK}.

Основная реализация miniKanren написана на языке Scheme~\cite{reasonedSchemer}, однако существует множество встраиваний
в ряд других языков, в том числе Clojure, Racket, OCaml, Haskell и другие.

miniKanren предоставляет набор базовых конструкций: унификация ($\equiv$),
конъюнкция $(\land)$, дизъюнкция $(\lor)$, введение свежей переменной (fresh), вызов реляционного отношения,
--- представляющий ядро языка, и разнообразные расширения, к примеру, оператор неэквивалентности
\origin{disequality constraint} или нечистые операторы, предоставляющие функциональность
отсечения из Prolog.

Классический пример --- программа конкатенации двух списков --- указан на рисунке~\ref{fig:appendo}.

\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]
$\text{append}^o$ X Y R =
  X $\equiv$ [] $\land$ Y $\equiv$ R $\lor$
  fresh (H X' R')
    (X $\equiv$ H :: X') $\land$
    (R $\equiv$ H :: R') $\land$
    $\text{appendo}^o$ X' Y R'
\end{lstlisting}

\caption{Пример программы на miniKanren (\lstinline{::} --- конструктор списка)}
\label{fig:appendo}
\end{figure}

Пояснение к программе:
список R является конкатенацией списков X и Y в случае, когда список X пуст, а Y равен R, либо
когда X и R раскладываются на голову и хвост, а их хвосты состоят в отношении конкатенации с Y.

Для выполнения конкатенации над списками необходимо сформировать \emph{запрос} (или \emph{цель}).
В запросе в аргументах указываются либо замкнутые термы, либо термы со свободными переменными. Результатом
выполнения является список подстановок для свободных переменных, при которых отношение выполняется
(когда свободных переменных нет, подстановка, соответственно, пустая).

На рисунке~\ref{fig:appendoExample} приведёт пример запроса, в котором мы хотим найти возможные значения
переменных \lstinline{Y} и \lstinline{R}. Потенциально может быть бесконечное число ответов, к примеру,
когда все аргументы в запросе --- переменные, поэтому в системах miniKanren есть возможность
запрашивать несколько первых ответов; в примере, это число 1. Ответы могут содержать в себе как
конкретные замкнутые термы (к примеру, числа), так и свободные переменные, которые
в примере обозначаются как $\text{\_.}_n$. В примере одна и также свободная переменная $\text{\_.}_0$
назначена и \lstinline{Y} и \lstinline{R}. Это означает, что какое бы ни было значение \lstinline{Y}, оно всегда
будет являться хвостом \lstinline{R}.

\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]
> run 1 (Y R) ($\text{append}^o$ [1, 2] Y R)
Y = $\text{\_.}_0$
R = 1 :: 2 :: $\text{\_.}_0$
\end{lstlisting}
\caption{Пример запуска отношения конкатенации.}
\label{fig:appendoExample}
\end{figure}

В определение miniKanren входит особый алгоритм поиска ответов --- чередующийся поиск \origin{interleaving search},
основанный на поиске в глубину, который рассматривает всё пространство поиска и гарантирует,
что если существует ответ, то алгоритм его предоставит за конечное время.
Для сравнения, обычный поиск в глубину, используемый в классическом Prolog при методе резолюций, может зациклиться
перед тем, как предоставить все ответы. Это свойство чередующегося поиска определяет, вместе
с отсутствием нечистых расширений, реляционность miniKanren. 

% Применимость
Хотя miniKanren уже применяется в индустрии для поиска лечения редких генетических
заболеваний в точной медицине\cite{medMK},
на данном этапе своего развития используется в основном в исследовательских целях.

Одно из интересных применений miniKanren --- {\it реляционные интерпретаторы}.

Для языка $L$ его интерпретатор -- это функция $\text{eval}_L$, которая принимает
на вход программу $p_L$ на этом языке, её вход $i$ и возвращает некоторый выход $o$
\[ \text{eval}_L (p_L, i) \equiv \llbracket p_L \rrbracket (i) = o,\]

где $\llbracket \bullet \rrbracket $ --- семантика языка L.
Тогда в miniKanren интерпретатор описывается отношением $\text{eval}^o_L(p_L, i, o)$.
При запуске такого отношения на разном наборе аргументов можно добиться интересных эффектов:
\begin{itemize}
\item по программе $p_L$ и выходу $o$ искать возможные входы $i$ (запуск программы в обратном направлении);
  %: $\text{eval}^o(\text{add}, I, 3)$
\item решать задачи поиска по задаче распознавания~\cite{lozov};
\item генерировать программы по заданной спецификации входа $i$ и выхода $o$
(техника программирования по примерам)\cite{unifiedMK}.
\end{itemize}

\todo{проблемы miniKanren: долгое вычисления сложных алгоритмов, долгие вычисления в обратном направлении.}

Одно из возможных решения проблем производительности --- специализация.
