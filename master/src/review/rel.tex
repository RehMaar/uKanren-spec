{\bf Реляционное программирование} --- это форма чистого логического программирования,
в котором программы задаются как набор математических {\it отношений}.

К примеру, сложение $X + Y = Z$ в терминах реляционного программирования может
быть выражено отношением (символ $o$ традиционно используется для обозначения отношения)
\[ \text{add}^o (X, Y, Z), \]
которое в зависимости от того, какие переменные заданы, порождает
все возможные значения переменных, при которых отношение выполняется:
\begin{itemize}
\item \rel{add}(1, 2, 3) --- проверка выполнимости отношения;
\item \rel{add}(1, 2, A) --- поиск всех таких A, при которых 1 + 2 = A;
\item \rel{add}(A, B, 3) --- поиск всех таких A и B, при которых A + B = 3;
\item \rel{add}(A, B, C) --- поиск всех троек A, B и С, при которых A + B = C.
\end{itemize}

Отношения не предполагают функциональных зависимостей между переменными, поэтому
поиск можно проводить в разных ``направлениях'', в зависимости от того, какие переменные
заданы, как показано выше в примере.

Когда же чистые отношения вырождаются в функциональные и появляется
явная зависимость в между переменными, тогда можно говорить про запуск
в ``прямом'' направлении (то есть задаются входные аргументы) и в ``обратном''
(при задании результата).

К примеру, отношение ``меньше'' для двух чисел X и Y можно задавать как \rel{less}(X, Y) и
получить чистое реляционное отношение, либо
как \rel{$\text{less}_2$}(X, Y, R), где R сообщает, состоят ли X и Y в отношении,
и получить функциональное, и тогда задание X и Y будет прямым направлением, а задание R --- обратным.

Реляционная парадигма раздвигает границы логического программирования в своей декларативности
и расширяет множество покрываемых задач.

% Ссылка на Булычева
%Одно из применений реляционной парадигмы --- {\it реляционные интерпретаторы}.
%Для языка $L$ его интерпретатор -- это функция $\text{eval}_L$, которая принимает
%на вход программу $p_L$ на этом языке, её вход $i$ и возвращает некоторый выход $o$:
%\[ \text{eval}_L (p_L, i) = \llbracket p_L \rrbracket (i) = o \]
%%Реляционную версию интерпретатора можно представить как отношение:
%%\[ \text{eval}_L^o(p_L, i, o). \]
%
%При запуске такого отношения на разном наборе аргументов можно добиться интересных эффектов:
%по программе $p_L$ и выходу $o$ искать возможные входы $i$,
%решать задачи поиска по задаче распознавания~\cite{lozov}, генерировать программы
%по заданной спецификации входа $i$ и выхода $o$ (Programming By Example,~\cite{unifiedMK}).
