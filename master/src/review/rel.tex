{\bf Реляционное программирование}~--- это форма чистого логического
программирования, в котором программы задаются как набор
математических {\it отношений}. Реляционное программирование направлено
на получение \emph{значимых} ответов, как бы ни использовались отношения
~\cite{byrdMK}.

Исторически, понятие реляционного программирования появилось
раньше~\cite{relML} и задавало саму концепцию программы как отношения,
когда логическое --- появилось позже и предоставляло реализацию его
идей~\cite{logicMJ}.
Однако в данной работе под реляционным программированием понимается
непосредственно так, как указано выше.

В терминах реляционного программирования, к примеру, сложение $X + Y = Z$
может быть выражено отношением\footnote{Символ $\ ^o$ традиционно
используется для обозначения отношения.}
\[\text{add}^o (X, Y, Z),\]
которое в зависимости от того, какие переменные заданы, порождает
все возможные значения переменных, при которых отношение выполняется:
\begin{itemize}
\item \rel{add}(1, 2, 3) --- проверка выполнимости отношения;
\item \rel{add}(1, 2, A) --- поиск всех таких A, при которых 1 + 2 = A;
\item \rel{add}(A, B, 3) --- поиск всех таких A и B, при которых A + B = 3;
\item \rel{add}(A, B, C) --- поиск всех троек A, B и С, при которых A + B = C.
\end{itemize}

Чистые отношения не предполагают функциональных зависимостей между переменными,
поэтому поиск можно проводить в разных ``направлениях'', в зависимости от
того, какие переменные заданы, как показано выше в примере.

Когда же отношения вырождаются в функциональные и появляется
явная зависимость между переменными, тогда можно говорить про запуск
в ``прямом'' направлении --- то есть задаются входные аргументы --- и в
``обратном'' --- при задании результата.

К примеру, отношение ``меньше'' для двух чисел X и Y можно задавать как
\rel{less}(X, Y) и получить чистое реляционное отношение, либо
как \rel{$\text{less}_2$}(X, Y, R), где R сообщает, состоят ли X и Y
в отношении, и получить функциональное, и тогда задание X и Y будет
прямым направлением, а задание R --- обратным.

% Отличительная черта реляционного программирования в том, что с каким бы
% набором аргументов отношение ни было запущено, обязательно должны быть
% найдены все ответы, если они есть. Для сравнения, в Prolog 

% Ссылка на Булычева
Одно из применений реляционной парадигмы --- {\it реляционные интерпретаторы}.
Для языка $L$ его интерпретатор -- это функция $\text{eval}_L$, которая принимает
на вход программу $p_L$ на этом языке, её вход $i$ и возвращает некоторый выход $o$:
\[ \text{eval}_L (p_L, i) \equiv \llbracket p_L \rrbracket (i) = o \]
Реляционную версию интерпретатора можно представить как отношение:
\[ \text{eval}_L^o(p_L, i, o). \]

При запуске такого отношения в разных направлениях можно добиться интересных
эффектов: не только вычислять результат, но и по программе $p_L$ и выходу $o$
искать возможные входы $i$ или вовсе генерировать программу по указанным
выходам и входам.
% решать задачи поиска по задаче распознавания~\cite{lozov},
%генерировать программы по заданной спецификации входа $i$ и выхода $o$~\cite{unifiedMK}.

Можно отметить, что языках, основанных на классическом Prolog, производить
подобные вычисления для получения вразумительных результатов не получится. 
