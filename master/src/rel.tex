{\bf Реляционное программирование} --- это форма чистого логического программирования,
в котором программы задаются как набор математических {\it отношений}.

К примеру, сложение $X + Y = Z$ в терминах реляционного программирования может
быть выражено отношением (символ $o$ традиционно используется для обозначения отношения)
\[ \text{add}^o(X, Y, Z), \]
которое в зависимости от того, какие переменные заданы, порождает
все возможные значения переменных, при которых отношение выполняется:
\begin{itemize}
\item $\text{add}^o(1, 2, 3)$ --- проверка выполнимости отношения;
\item $\text{add}^o(1, 2, A)$ --- поиск всех таких A, при которых $1 + 2 = A$;
\item $\text{add}^o(A, B, 3)$ --- поиск всех таких A и B, при которых $A + B = 3$;
\item $\text{add}^o(A, B, C)$ --- поиск всех троек A, B и С, при которых $A + B = C$.
\end{itemize}

Отношения не предполагают функциональных зависимостей между переменными, поэтому
поиск можно проводить в разных ``направлениях'', в зависимости от того, какие переменные
заданы. Когда же чистые отношения вырождаются в функциональные, появляется
явная зависимость в между переменными; тогда можно говорить про запуск
в ``прямом'' направлении (то есть задаются входные аргументы) и в ``обратном''
(при задании результата).

\todo{применение}

% Ссылка на Булычева
%Одно из применений реляционной парадигмы --- {\it реляционные интерпретаторы}.
%Для языка $L$ его интерпретатор -- это функция $\text{eval}_L$, которая принимает
%на вход программу $p_L$ на этом языке, её вход $i$ и возвращает некоторый выход $o$:
%\[ \text{eval}_L (p_L, i) = \llbracket p_L \rrbracket (i) = o \]
%%Реляционную версию интерпретатора можно представить как отношение:
%%\[ \text{eval}_L^o(p_L, i, o). \]
%
%При запуске такого отношения на разном наборе аргументов можно добиться интересных эффектов:
%по программе $p_L$ и выходу $o$ искать возможные входы $i$,
%решать задачи поиска по задаче распознавания~\cite{lozov}, генерировать программы
%по заданной спецификации входа $i$ и выхода $o$ (Programming By Example,~\cite{unifiedMK}).
