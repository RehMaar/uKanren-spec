%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание общего алгоритма суперкомпиляции
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

На основе введёных выше терминов и операторов можно составить обобщённый алгоритм
суперкомпиляции, который не затрагивает особенности и трудности реализации на Haskell.
% Однако прежде необходимо ввести ряд необходимых понятий.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Описание окружения
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\emph{Окружение} для суперкомпиляции должно сохранять следующие объекты:
%\begin{itemize}
%\item подстановку, в которой содержатся все накопленные непротиворечивые унификации,
%      необходимую в процессе прогонки для проверки новых унификаций;
%\item первую свободную семантическую переменную, необходимую для генерации свежих переменных,
%      к примеру, при абстракции;
%\item определение программы, необходимое для замены вызова на своё тело.
%\end{itemize}
% 
% \todo{Что-то ещё об этом нужно написать!}

Обобщённый алгоритм суперкомпиляции в псевдокоде представлен на рисунке~\ref{fig:scalgogen}.

\begin{figure}[h!]
% обобщение вверх
% else if $\exists$ parent: parent $\genup$ configuration
% then
%    node $\larrow$ generalize(configuration, parent)
%    addUp(env, tree, parent, node)

\begin{lstlisting}[escapechar=@]
supercomp(program, query):
  env $\larrow$ createEnv program
  configuration $\larrow$ initialize query
  graph $\larrow$ emptyTree
  drive(env, graph, configuration)
  return residualize graph

drive(env, graph, configuration):
  if configuration is empty  @\label{line:success}@
  then add(env, graph, success node)
  else if $\exists$ parent: configuration $\variant$ parent @\label{line:renaming}@
  then add(env, graph, renaming node)
  else if $\exists$ parent: parent $\embed^+$ configuration @\label{line:abstraction}@
  then
    add(env, graph, abstraction node)
    children $\larrow$ generalize(configuration, parent) @\label{line:gen}@
    $\forall \text{child} \in \text{children}:$
      drive(env, graph, child)
  else @\label{line:unfolding}@
    add(env, graph, unfolding node)
    children $\larrow$ unfold(env, configuration) @\label{line:unfold}@
    $\forall \text{child} \in \text{children}:$
      drive(env, graph, child)
\end{lstlisting}
\caption{Обобщённый алгоритм суперкомпиляции.}
\label{fig:scalgogen}
\end{figure}

Алгоритм суперкомпиляции принимает на себя программу и запрос,
на который необходимо специализировать программу, и после
инициализации начальных значений, включающих в себя некоторое \emph{окружения программы},
в котором хранятся все вспомогательные структуры, запускает процесс прогонки.
Прогонка производится до схождения и производит следующие действия в
зависимости от состояния:
\begin{itemize}
\item если конфигурация пустая (строка~\ref{line:success}), это означает, что вычисления
      успешно сошлись в конкрутную подстановку. В таком случае происходит добавление
      в граф листового узла с этой подстановкой;
\item если существует такая родительская конфигурация, что она является вариантом текущей (строка~\ref{line:renaming}),
      то происходит свёртка и в граф добавляется листовой узел с ссылкой на родителя;
\item если же среди родителей находится такой, на котором срабатывает свисток (строка~\ref{line:abstraction}),
      тогда производится обобщение, порождающее дочерние конфигурации (строка~\ref{line:gen}),
      на которых продолжается процесс прогонки;
\item иначе происходит шаг символьного вычисления (строка~\ref{line:unfolding}), на котором
      порождаются конфигурации.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание шага unfolding'а
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Стратегия символьного вычисления определяется функцией \lstinline{unfold}
(строка~\ref{line:unfold}), что означает ``развёртывание'' по определеням вызовы реляционных отношений.
Развёртка по данной конфигурации $C$ порождает
множество конфигурации $\{ C_1, \dots, C_n \}$, описывающих состояния в которое может перейти
процесс реального исполнения программы. Классически, шаг символьного
вычисления соответствует семантике языка, который суперкомпилируется,
и для \ukanren существует сертифицированная семантика\cite{semanticMK},
однако описание шага символьного вычисления \ukanren для суперкомпиляции 
усложнено тем, что реляционные языки не исполняются привычным образом,
как, к примеру, функциональные программы, и \emph{поиск}, вшитый в семантику,
не ложится на суперкомпиляцию прямым образом.

Тогда порождённую конфигурацию можно рассматривать не как непосредственный
шаг вычисления, но как возможное состояние, в которое может перейти программа.
Такое состояние появляется путём раскрытия тела одного или нескольких
конъюнктов конфигурации.

К примеру, рассмотрим часть программы на \ukanren на рисунке~\ref{fig:unfoldEx}, в котором
определены какие-то отношения \lstinline{f} и \lstinline{g}.
\begin{figure}[h!]
\begin{lstlisting}
f(a) = f'(a)$\lor$f''(a)
g(a, b) = g'(a)$\land$g''(b)
\end{lstlisting}
\caption{Пример отношений для демонстрации шага символьных вычислений}
\label{fig:unfoldEx}
\end{figure}

Допустим, на шаге суперкомпиляции алгоритм обрабатывает конфигурацию
\lstinline{f($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)}
хотим сделать шаг символьного вычисления. Рассмотрим несколько способов породить новые конфигурации.
\begin{itemize}
\item Если раскроется определение \lstinline{f}, то будут получены новые конфигурации 
      \lstinline{f'($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)} и
      \lstinline{f''($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)}.
\item Если раскроется определение \lstinline{g}, то будет получена новая конфигурация 
      \lstinline{f($\text{v}_\text{1}$)$\land$g'($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)}.
\item Если раскроются оба определения \lstinline{f} и \lstinline{g}, то будут получены новые конфигурации 
      \lstinline{f'($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)} и
      \lstinline{f''($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)}.
\end{itemize}

Последний набор конфигураций --- это полный набор состояний, в которые процесс вычислений может
прийти. В первых двух наборах, можно отметить, порождённые конфигурации не исключают
возможные состояния процессов, отображённые в последнем наборе, они могут появится на последующих шагах вычисления,
если перед этим ветвь исполнения не будет остановлена из-за противоречивой подстановки.

Таким образом, какой-бы способ развёртывания определений не был бы выбран, он не будет
исключать состояния, в которые процесс вычисления теоретически может прийти, но выбор
разных стратегий развёртывания может систематически приводить к разным деревьям процессов,
а следовательно --- к различным эффектам специализации.

\todo{Слова про терминируемость за счёт переиспользования алгоритма CPD и гомеоморфного вложения.}
