%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание "графа" процессов
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Представление графа процессов в Haskell затруднено тем, что графовые
структуры данных обычно требуют ссылок на произвольные узлы,
что приводит к появлению перекрёсных ссылок. Прямая реализация этой
идеи сложна в разработке и поддержке и не является идиоматичной.
Использование \emph{IORef}\footnote{https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-IORef.html},
хотя и предоставляет мутабельность, приводит к неоправданному усложнению кода всего проекта,
избавляя код от функциональной чистоты.

Заметим, что графовость этой структуре данных придают \emph{обратные рёбра}
(то есть рёбра от детей к родителям), которые появляются при свёртке, когда ребёнок
является переименованием родителя.
Тогда, если уметь сохранять или восстанавливать информацию об этой связи, то
достаточным будет представить граф в качестве \emph{дерева} процессов.
Древовидные структура однозначно отображается на процесс символьных вычислений,
а также они легко и идиоматично в Haskell.

Структура дерева процессов представлена в виде дерева на рисунке~\ref{fig:ptree}.

\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]

$\text{\color{black!70} \{- Описанно в абстрактном синтаксисе \ukanren -\}}$
data Expr = $\dots$

type Subs = Variable $\mapsto$ Term

data Tree where
  Failure     :: Tree
  Success     :: Subst $\rarrow$ Tree
  Renaming    :: Expr $\rarrow$ Subst $\rarrow$ Tree
  Abstraction :: Expr $\rarrow$ Subst $\rarrow$ List Tree $\rarrow$ Tree
  Generalizer :: Subst $\rarrow$ Tree $\rarrow$ Tree
  Unfolding   :: Expr $\rarrow$ Subst $\rarrow$ List Tree $\rarrow$ Tree
\end{lstlisting}
\caption{Описание дерева процессов.}
\label{fig:ptree}
\end{figure}

Конфигурация определена как выражение \lstinline{Expr} со свободными переменными;
определение типа соответствует абстрактному синтаксису в разделе~\ref{sec:scmk} на рисунке~\ref{fig:syntax}.
В узле дерева процессов хранится конфигурация, приведённая к форме, содержащей только конъюнкцию вызовов
реляционного отношения. Это сделано из тех соображений, что, во-первых, дизъюнкция представляет
собой ветвление вычислений, посему, соответственно, представляется как ветвление в дереве процессов,
во-вторых, унификации производятся во время символьных вычислений и добавляются в подстановку,
в-третьих, так как введение свежей переменной оказывает влияние лишь на состояние, в котором производятся вычисления,
неосмысленно сохранять его в конфигурации.

Подстановка \lstinline{Subst} соответствует своему математическому определению как отображению из
переменных в термы.
Узлы дерева процессов представляют шаги суперкомпиляции и исходы вычисления выражений:
\begin{itemize}
\item \lstinline{Failure} обозначает неудавшееся вычисления. Такой исход
      случается при появлении противоречивых подстановок;
\item \lstinline{Success}, напротив, обозначает удавшееся вычисление, которое свелось к подстановке \lstinline{Subst};
\item \lstinline{Renaming} обозначает узел, конфигурация которой является переименованием какого-то родительского узла.
\item \lstinline{Abstraction} обознает узел, который может быть обобщён на одного из родителей.
      После обобщения может появится несколько конфигураций, которые являются результатом применения разделения.
      Эти конфигурации добавляются в качестве списка дочерних поддеревьев в текущий узел. 
\item \lstinline{Generalizer} \todo{описать после того, как опишешь обобщение}
\item \lstinline{Unfolding} обознает шаг символьного вычисления, на котором  
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание окружения
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Окружение} для суперкомпиляции должно сохранять следующие объекты:
\begin{itemize}
\item подстановку, в которой содержатся все накопленные непротиворечивые унификации,
      необходимую в процессе прогонки для проверки новых унификаций;
\item первую свободную семантическую переменную, необходимую для генерации свежих переменных,
      к примеру, при абстракции;
\item определение программы, необходимое для замены вызова на своё тело.
\end{itemize}

\todo{Что-то ещё об этом нужно написать!}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание шага unfolding'а
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{UUUNFOLDING}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание общего алгоритма суперкомпиляции
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Обобщённый алгоритм суперкомпиляции}

Обобщённый алгоритм суперкомпиляции представлен на рисунке~\ref{fig:scalgogen}.
\todo{Пояснения?}

\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]
drive(env, tree, expression):
  if expression is empty
  then add(env, tree, success node)
  else if $\exists \text{parent}:$ expression is renaming of parent
  then add(env, tree, renaming node)
  $\text{\color{red}TODO: Ввести нотацию для } \embed^+$
  else if $\exists$ parent: parent $\embed^+$ expression
  then
     node $\larrow$ abstractUp(expression, parent)
     addUp(env, tree, parent, node)
  else else if $\exists$ parent: parent $\embed^*$ expression
  then
    add(abstraction, node)
    children $\larrow$ abstract(expression, parent)
    $\forall \text{child} \in \text{children}:$
      drive(tree, child)
  else
    add(unfolding node)
    children $\larrow$ unfold(expression)
    $\forall \text{child} \in \text{children}:$
      drive(tree, child)
\end{lstlisting}
\caption{Обобщённый алгоритм суперкомпиляции}
\label{fig:scalgogen}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание конкретного алгоритма суперкомпиляции
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Конкретный алгоритм суперкомпиляции}

Наличие операции обобщения вверх предполагает, что необходимо умение передвигаться по дереву вверх и изменять его. 
Реализация в Haskell этой идеи --- задача крайне нетривиальная. Возможно представлять
деревья в мутабельных массивах, однако при обобщении необходимо удалять целые поддеревья,
что при таком подходе сложная операция.

Классическим способом решения этой проблемы являются \emph{зипперы}\cite{zipper}.
Эта идиома предлагает рассматривать структуру данных как пару из элемента,
на котором установлен фокус, и контекста, который представляется как структура данных
с ``дыркой'', в котором сфокусированный элемент должен находиться.

К примеру, зиппер для списка \lstinline{[1, 2, 3, 4]} при фокусе на 3 представляется
таким образом: \lstinline{(3, ([2, 1, 0], [4, 5, 6]))}.
Тогда перефокусировка вправо или влево на один элемент происходит за константу,
как и замена элемента, для которой достаточно заменить первую компоненту пары.
В то время как, в силу того, что операция взятия элемента в связном списке по индексу
происходит за линейное время от длины списка, взятие элемента слева от 3 также
будет происходить за линейное время, как и, соответственно, модификация списка.

Для деревьев с произвольным количеством детей зиппер может выглядеть
как пара из текущего узла и списка родителей, отсортированного в порядке
близости к узлу (рисунок~\ref{fig:zipper}). 
\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]
data Parent = Parent { children :: ListZipper Node }
type TreeZipper = (Node, List Parent)
\end{lstlisting}
\caption{Пример структуры зиппера для деревьев}
\label{fig:zipper}
\end{figure}

Родительский (структура \lstinline{Parent}) cписок детей представлен в виде зиппера (поле \lstinline{children})
для списка, в котором происходит фокус: у непосредственного родителя --- на элемент в фокусе, а у остальных
родителей --- на предыдущего в порядке сортировки.\todo{more?}

При представлении дерева процессов в идиоме зипперов основа алгоритма суперкомпиляции
принимает форму описания действий при смене состояния зиппера.
\todo{TODO}

\subsubsection{Модификации базового алгоритма суперкомпиляции}
