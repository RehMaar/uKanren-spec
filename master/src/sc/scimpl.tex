%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание "графа" процессов
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Представление графа процессов в Haskell затруднено тем, что графовые
структуры данных обычно требуют ссылок на произвольные узлы,
что приводит к появлению перекрёсных ссылок. Прямая реализация этой
идеи сложна в разработке и поддержке и не является идиоматичной.
Использование \emph{IORef}\footnote{https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-IORef.html},
хотя и предоставляет мутабельность, приводит к неоправданному усложнению кода всего проекта,
избавляя код от функциональной чистоты.

Заметим, что графовость этой структуре данных придают \emph{обратные рёбра}
(то есть рёбра от детей к родителям), которые появляются при свёртке, когда ребёнок
является переименованием родителя.
Тогда, если уметь сохранять или восстанавливать информацию об этой связи, то
достаточным будет представить граф в качестве \emph{дерева} процессов.
Древовидные структура однозначно отображается на процесс символьных вычислений,
а также с ними легко и идиоматично работать в Haskell.

Структура дерева процессов представлена на рисунке~\ref{fig:ptree}.

\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]
type Conf = Conjunction (RelationCall FreeVar)

type Subs = Variable $\mapsto$ Term

data Tree where
  Failure     :: Tree
  Success     :: Subst $\rarrow$ Tree
  Renaming    :: Conf $\rarrow$ Subst $\rarrow$ Tree
  Abstraction :: Conf $\rarrow$ Subst $\rarrow$ List Tree $\rarrow$ Tree
  Generalizer :: Subst $\rarrow$ Tree $\rarrow$ Tree
  Unfolding   :: Conf $\rarrow$ Subst $\rarrow$ List Tree $\rarrow$ Tree
\end{lstlisting}
\caption{Описание дерева процессов.}
\label{fig:ptree}
\end{figure}

Конфигурация \lstinline{Conf} определена как выражение со свободными переменными.
В узле дерева процессов хранится конфигурация, приведённая к форме, содержащей только конъюнкцию вызовов
реляционного отношения. Это сделано из тех соображений, что, во-первых, дизъюнкция представляет
собой ветвление вычислений, посему, соответственно, представляется как ветвление в дереве процессов,
во-вторых, унификации производятся во время символьных вычислений и добавляются в подстановку,
в-третьих, так как введение свежей переменной оказывает влияние лишь на состояние, в котором производятся вычисления,
неосмысленно сохранять его в конфигурации.

Подстановка \lstinline{Subst} соответствует своему математическому определению как отображение из
переменных в термы.
Узлы дерева процессов представляют шаги суперкомпиляции и исходы вычисления выражений:
\begin{itemize}
\item \lstinline{Failure} обозначает неудавшееся вычисления. Такой исход
      случается при появлении противоречивых подстановок;
\item \lstinline{Success}, напротив, обозначает удавшееся вычисление, которое свелось к подстановке \lstinline{Subst};
\item \lstinline{Renaming} обозначает узел, конфигурация которой является переименованием какого-то родительского узла.
\item \lstinline{Abstraction} обознает узел, который может быть обобщён на одного из родителей;
      После обобщения может появится несколько конфигураций, которые являются результатом применения разделения.
      Эти конфигурации добавляются в качестве списка дочерних поддеревьев в текущий узел;
\item \lstinline{Generalizer} хранит себе унификатор, который порождается во время обобщения
      двух термов, и поддерево с обобщённой конфигурацией;
\item \lstinline{Unfolding} обознает шаг символьного вычисления, на котором произошёл шаг вычислений
      и по рассматриваемой на этом шаге конфигурации породились новые конфигурации.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание окружения
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Окружение} для суперкомпиляции должно сохранять следующие объекты:
\begin{itemize}
\item подстановку, в которой содержатся все накопленные непротиворечивые унификации,
      необходимую в процессе прогонки для проверки новых унификаций;
\item первую свободную семантическую переменную, необходимую для генерации свежих переменных,
      к примеру, при абстракции;
\item определение программы, необходимое для замены вызова на его тело.
\end{itemize}
% \todo{Что-то ещё об этом нужно написать?}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Описание шага unfolding'а
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Шаг символьного вычисления по данной конфигурации $C$ порождает
% множество конфигурации $\{ C_1, \dots, C_n \}$, описывающих состояния в которое может перейти
% процесс реального исполнения программы. Классически, шаг символьного
% вычисления соответствует семантике языка, который суперкомпилируется,
% и для \ukanren существует сертифицированная семантика\cite{semanticMK},
% однако описание шага символьного вычисления \ukanren для суперкомпиляции 
% усложнено тем, что реляционные языки не исполняются привычным образом,
% как, к примеру, функциональные программы, и \emph{поиск}, вшитый в семантику,
% не ложится на суперкомпиляцию прямым образом.

% Тогда порождённую конфигурацию можно рассматривать не как непосредственный
% шаг вычисления, но как возможное состояние, в которое может перейти программа.
% Такое состояние появляется путём раскрытия тела одного или нескольких
% конъюнктов конфигурации.

% К примеру, рассмотрим часть программы на \ukanren на рисунке~\ref{fig:unfoldEx}, в котором
% определены какие-то отношения \lstinline{f} и \lstinline{g}.
% \begin{figure}[h!]
% \begin{lstlisting}
% f(a) = f'(a)$\lor$f''(a)
% g(a, b) = g'(a)$\land$g''(b)
% \end{lstlisting}
% \caption{Пример отношений для демонстрации шага символьных вычислений}
% \label{fig:unfoldEx}
% \end{figure}

% Допустим, на шаге суперкомпиляции алгоритм обрабатывает конфигурацию
% \lstinline{f($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)}
% хотим сделать шаг символьного вычисления. Рассмотрим несколько способов породить новые конфигурации.
% \begin{itemize}
% \item Если раскроется определение \lstinline{f}, то будут получены новые конфигурации 
%       \lstinline{f'($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)} и
%       \lstinline{f''($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$, $\text{v}_\text{2}$)}.
% \item Если раскроется определение \lstinline{g}, то будет получена новая конфигурация 
%       \lstinline{f($\text{v}_\text{1}$)$\land$g'($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)}.
% \item Если раскроются оба определения \lstinline{f} и \lstinline{g}, то будут получены новые конфигурации 
%       \lstinline{f'($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)} и
%       \lstinline{f''($\text{v}_\text{1}$)$\land$g($\text{v}_\text{1}$)$\land$g''($\text{v}_\text{2}$)}.
% \end{itemize}

% Последний набор конфигураций --- это полный набор состояний, в которые процесс вычислений может
% прийти. В первых двух наборах, можно отметить, порождённые конфигурации не исключают
% возможные состояния процессов, отображённые в последнем наборе, они могут появится на последующих шагах вычисления,
% если перед этим ветвь исполнения не будет остановлена из-за противоречивой подстановки.

% Таким образом, какой-бы способ развёртывания определений не был бы выбран, он не будет
% исключать состояния, в которые процесс вычисления теоретически может прийти, но выбор
% разных стратегий развёртывания может систематически приводить к разным деревьям процессов,
% а следовательно, приводить к различным эффектам специализации.

Базовой стратегией порождения новых конфигураций выбрана \emph{полная стратегия развёртывания},
пример которой был показан выше, при которой мы заменяем определния всех реляционных вызовов
конфигурации.

В суперкомпиляции, в отличие от методов частичной дедукции, в обобщение включён
шаг обобщения вверх, при котором происходит не подвешивание обобщённой конфигурации
в качестве потомка конфигурации, которая обобщалась, но замена самого родителя на
новую конфигурацию, поддерево же родителя уничтожается. Для определения
необходимости обобщать вверх введём предикат $e_1 \genup e_2$, который
определяет, что $e_1 \strictinst e_2$ и $e_2 \not\strictinst e_1$.
Такое ограничение необходимо из-за того, что суперкомпилятор оперирует
конъюнкциями выражений и делает операции разделения и обобщения вниз
за один шаг с конъюнкциями возможно разной длины, однако для обобщения
вверх необходимо удоставериться, что одни \todo{todo}


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % Описание общего алгоритма суперкомпиляции
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \subsubsection{Обобщённый алгоритм суперкомпиляции}

% На основе введёных выше терминов и операторов можно составить обобщённый алгоритм
% суперкомпиляции, который не затрагивает особенности и трудности реализации на Haskell.
% Обобщённый алгоритм суперкомпиляции на псевдокоде представлен на рисунке~\ref{fig:scalgogen}.

% \begin{figure}[h!]
% \begin{lstlisting}
% drive(env, tree, configuration):
%   if configuration is empty
%   then add(env, tree, success node)
%   else if $\exists$ parent: configuration $\variant$ parent
%   then add(env, tree, renaming node)
%   else if $\exists$ parent: parent $\genup$ configuration
%   then
%      node $\larrow$ generalize(configuration, parent)
%      addUp(env, tree, parent, node)
%   else if $\exists$ parent: parent $\embed^+$ configuration
%   then
%     add(env, tree, abstraction, node)
%     children $\larrow$ generalize(configuration, parent)
%     $\forall \text{child} \in \text{children}:$
%       drive(env, tree, child)
%   else
%     add(env, tree, unfolding node)
%     children $\larrow$ unfold(env, configuration)
%     $\forall \text{child} \in \text{children}:$
%       drive(env, tree, child)
% \end{lstlisting}
% \caption{Обобщённый алгоритм суперкомпиляции.}
% \label{fig:scalgogen}
% \end{figure}


% % Привести пример

% % \begin{figure}[h!]
% % \caption{Пример порождённого дерева для запроса X}
% % \label{fig:treeExample}
% % \end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Описание конкретного алгоритма суперкомпиляции
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Конкретный алгоритм суперкомпиляции}

Наличие операции обобщения вверх предполагает, что необходимо умение передвигаться по дереву вверх и изменять его. 
Реализация в Haskell этой идеи --- задача крайне нетривиальная. Возможно представлять
деревья в мутабельных массивах, однако при обобщении необходимо удалять целые поддеревья,
что при таком подходе сложная операция.

Классическим способом решения этой проблемы являются \emph{зипперы}\cite{zipper}.
Эта идиома предлагает рассматривать структуру данных как пару из элемента,
на котором установлен фокус, и контекста, который представляется как структура данных
с ``дыркой'', в котором сфокусированный элемент должен находиться.

К примеру, зиппер для списка \lstinline{[1, 2, 3, 4]} при фокусе на 3 представляется
таким образом: \lstinline{(3, ([2, 1, 0], [4, 5, 6]))}.
Тогда перефокусировка вправо или влево на один элемент происходит за константу,
как и замена элемента, для которой достаточно заменить первую компоненту пары.
В то время как, в силу того, что операция взятия элемента в связном списке по индексу
происходит за линейное время от длины списка, взятие элемента слева от 3 также
будет происходить за линейное время, как и, соответственно, модификация списка.

Для деревьев с произвольным количеством детей зиппер может выглядеть
как пара из текущего узла и списка родителей, отсортированного в порядке
близости к узлу (рисунок~\ref{fig:zipper}). 
\begin{figure}[h!]
\begin{lstlisting}[mathescape,language=Haskell,extendedchars=\true,frame=single,basicstyle=\ttfamily]
data Parent = Parent { children :: ListZipper Node }
type TreeZipper = (Node, List Parent)
\end{lstlisting}
\caption{Пример структуры зиппера для деревьев}
\label{fig:zipper}
\end{figure}

Родительский (структура \lstinline{Parent}) cписок детей представлен в виде зиппера (поле \lstinline{children})
для списка, в котором происходит фокус: у непосредственного родителя --- на элемент в фокусе, а у остальных
родителей --- на предыдущего в порядке сортировки.\todo{more?}

При представлении дерева процессов в идиоме зипперов основа алгоритма суперкомпиляции
принимает форму описания действий при смене состояния зиппера.
\todo{TODO}

\subsubsection{Модификации базового алгоритма суперкомпиляции}

\textbf{Поиск узлов для переименования среди всех вычисленных поддеревьев}

В базовом алгоритме суперкомпиляции поиск узлов на которые происходят переименования происходит
среди родителей. Это напрямую соотносится с понятием символьных вычислений: по достижении
узла, которое является переименованием уже встреченного, вычисление переходит на родительский узел.
Однако довольно части встречается, что в разных поддеревьях дерева процессов стречаются одинаковые
конфигурации, поддеревья которых оказываются полностью идентичными. В таком случае, кажется
очевидной оптмизация, при которой мы запоминаем вычисленные поддеревья и в случае,
когда мы встречаем схожу конфигурацию, не вычисляем поддерево заново, добавляя ссылку на него.
\todo{Показать, почему это ничего не сломает}

\textbf{Стратегии развёртывания реляционных вызовов}

Как уже говорилось, разные стратегии развёртывания реляционных вызовов могут привести к разным
эффектам специализации. К примеру, полная стратегия развёртывания, которая была принята за базовую,
приводит к \emph{таплингу} \origin{tupling}\cite{tupling} --- оптмизации, при которой
множество проходов по одной структуре данных заменяется на один проход.

% Может, показать, что оно круто всё строит?

Основной недостаток базового подхода в том, что он для получения всех возможных состояний
производит декартово производение тел вызовов в конъюнкциях, что приводит
к сильному разрастанию дерева процессов и, как следствия, сильно требователен к вычислительным ресурсам.
Вследствие чего реализация новых стратегий развёртывания производится не только в исследовательских,
но и прикладных целях.

Для лёгкой подмены стратегий суперкомпиляции был разработан специальный интерфейс \lstinline{UnfoldableGoal}
(рисунок~\ref{fig:unfoldable}).
\begin{figure}[h!]
\begin{lstlisting}
class Unfoldable a where
   initialize :: Conf $\rarrow$ a
   get        :: a $\rarrow$ Conf
   unfoldStep :: a $\rarrow$ Env $\rarrow$ List (Env, a)
\end{lstlisting}
\caption{Интерфейс для различных стратегий развёртывания.}
\label{fig:unfoldable}
\end{figure}

Предоставляемые интерфейсом функции используются в алгоритме суперкомпиляции следующим образом:
\begin{itemize}
\item \lstinline{initialize} оборачивает конфигурацию в структуру, в которой может содержаться
      вспомогательная информация для процесса развёртывания;
\item \lstinline{get} позволяет получить конфигурацию для применения её к операциям, не зависящим
      от стратегий;
\item \lstinline{unfoldStep} непосредственно проводит шаг вычисления на основе текущей конфигурации
      и её окружения, порождая новые конфигурации с соответствующими им состояниями.
\end{itemize}

В работе рассмотрен и реализован ряд стратегий, описанные ниже.

\begin{itemize}
\item {\bf Последовательная стратегия развёртывания}, при которой отслеживается,
      какой вызов был раскрыт на предыдущем шаге, чтобы на текущем
      раскрыть следующий за ним.\todo{todo}
\item {\bf Нерекурсивная стратегия развёртывания}, при которой в первую очередь
      раскрывается нерекурсивный вызов в конфигурации. Нерекурсивность определяется
      лишь тем, содержит ли определение реляционный вызов самого себя. Более сложный
      анализ структуры функций не мог бы быть использован в силу того, что тогда
      было бы необходимо реализовать класс алгоритмов анализа, что совершенно отдельная задача.

      Ожидается, что при нерекурсивной стратегии развёртывания из конфигураций
      будут как можно быстрее появляться выражения, которые могут быть сокращены
      или вовсе удалены из-за унификации (к примеру, отношения, кодирующие
      таблицы истинности, такие как \rel{and}) или привести к скорой свёрте.
      \todo{todo}.

\item {\bf Стратегия развёртывания вызовов с минимальным количеством ветвлений},
      при которой на каждом шаге вычисления будет появляться минимально возможное количество
      конфигураций, что приведёт к минимальной ветвистости дерева.
\end{itemize}

% \subparagraph{Смешанная стратегия развёртывания}
% \todo{Ещё нужно бы проработать}

\textbf{Частичный или полный отказ от обобщения вверх}

Обобщение вверх приводит к тому, что происходит замена целого поддерева процессов
предка, на которого обобщается конфигурация. Иногда это может приводить к тому, что
теряются аргументы частично известного входа. К примеру, на рисунке~\ref{fig:genup}
представлено дерево процессов, при котором происходит обобщение вверх.
\begin{figure}[h!]
\center
\begin{tikzpicture}[->,node distance=2cm, sibling distance=5cm]
                                                            
  \tikzstyle{conf}=[rectangle,draw, rounded corners=.8ex]

  \node[conf] (root) {\rel{reverse}($a$, $a$)} ;
  \node[conf] (gen) [below of = root] {Generalizer: $\{ v_1 \mapsto a, v_2 \mapsto a \}$};
  \node[conf] (node) [below of = gen] {\rel{reverse}($v_1$, $v_2$)};
  \node (rest)[below of = node] {$\cdots$};
   \path (root) edge (gen)
         (gen) edge (node)
         (node) edge (rest);
  % \path (root) edge node[above left,pos=1] {$\{a \mapsto \text{Zero}\}$} (childLeft)
  %       (root) edge node[above right,pos=1]{$\{a \mapsto \text{Succ}(a_1)\}$}(childRight)
  %       (childLeft) edge (left)
  %       (childRight) edge (childRight2)
  %       (childRight2) edge[bend right=90] (root);
\end{tikzpicture}
\caption{Демонстрация потери информации при обобщении вверх.}
\label{fig:genup}
\end{figure}
\todo{пояснения к примеру}

В случае же, когда обощение происходит на сам корень дерева, теряется эффект протягивания
констант.

\textbf{Обобщение на все вычисленные узлы, не только на родительские}
\todo{Понять, почему это не противоречит методам суперкомпиляции}

\textbf{Расширение языка \ukanren c помощью операции неэквивалентности}

Множество операции в оргинальном \ukanren покрывает все нужды реляционного программирования,
однако на ряде программа оно вычислительно допускает пути исполнения, которые не приводят
к успеху, однако сообщить об этом не представляется возможным.

К примеру, на рисунке~\ref{fig:lookup} изображена операция поиска значения по ключу
в списке пар ключ-значения \rel{lookup}.

\begin{figure}[h!]
\begin{lstlisting}
$\text{lookup}^o$ K L R =
   (K', V) :: L' $\equiv$ L $\land$
   (K' $\equiv$ K $\land$ V $\equiv$ R $\lor$ $\text{lookup}^o$ K L' R)
\end{lstlisting}
\caption{Отношения поиска значения по ключу.}
\label{fig:lookup}
\end{figure}

В соответствии с программой список \lstinline{L} должен иметь в голове пару из ключа и значения \lstinline{(K', V)}
и либо  этот ключ \lstinline{K'} унифицируется с искомым ключом \lstinline{K} и
значение \lstinline{V} --- с результатом \lstinline{R},
либо поиск происходит в хвосте списка \lstinline{L'}. Проблема этой программы в том,
что если унификация \lstinline{(K',V)::L' $\equiv$ L} прошла успешно и был
найден результат, то поиск всё равно продёт во вторую ветку с рекурсивным вызовом и будет
искать значение дальше, хотя по семантике поиска ключа в списке должен вернуться лишь одно значение.
Более того, суперкомпилятору тоже придётся учитывать и, возможно, проводить вычисления,
которые не принесут никакой пользы.

В miniKanren существует операция неэквивалентности $t_1 \not\equiv t_1$, вводящее
ограничение неэквивалентности \origin{disequality contraints}\cite{mkConstr}.
Операция неэквивалентности определяет, что два терма $t_1$ и $t_2$ никогда не должны быть равны,
накладывая ограничения на возможные значения свободных переменных терма.

Расширение синтаксиса \ukanren представлено на рисунке~\ref{fig:syntaxExt}.

\begin{figure}[h!]
\centering
\[\begin{array}{ccll}
\mathcal{G}   & = & \hspace{1cm} \dots & \\
              &   & \hspace{1cm} \mathcal{T_X}\not\equiv\mathcal{T_X} \hspace{2cm} &\mbox{дезунификация} \\
\end{array}\]
\caption{Расширение синтаксиса \ukanren относительно указанного на рисунке~\ref{fig:syntax}.}
\label{fig:syntaxExt}
\end{figure}

Исправленная версия отношения \rel{lookup} представлена на рисунке~\ref{fig:lookupExt}.

\begin{figure}[h!]
\begin{lstlisting}
$\text{lookup}^o$ K L R =
   (K', V) :: L' $\equiv$ L $\land$
   (K' $\equiv$ K $\land$ V $\equiv$ R $\lor$
    K' $\not\equiv$ K $\land$ $\text{lookup}^o$ K L' R)
\end{lstlisting}
\caption{Исправленное отношение поиска значения по ключу.}
\label{fig:lookupExt}
\end{figure}

В такой реализации две по сути исключающие друг друга ветви исполнения будут исключать друг друга
и при вычислении запросов, и при суперкомпиляции.

Для реализации ограничения неэквивалентности вводится новая сущность под названием
``хранилище ограничений'' $\Omega$ \origin{constraints store}, которое используется для проверки
нарушений неэквивалентности. Окружение расширяется хранилищем ограничений, которое затем используется
при унификации и при добавлении новых ограничений.

Тогда нужно ввести следующие модификации в алгоритм унификации конфигурации, который собирает все
операции унификации в конъюнкции перед тем, как добавить её в множество допустимых конфигураций.
\begin{itemize}
\item При встрече операции дезунификации $t_1 \not\equiv t_2$ необходимо произвести следующие действия.
      Применить накопленную подстановку к термам $t_1 \theta = t_1'$ и $t_2 \theta = t_2'$ и 
      унифицировать термы $t_1'$ и $t_2'$. Если получился пустой унификатор, значит, эти термы
      равны и ограничение нарушено. В таком случае суперкомпилятор покинет эту
      ветвь вычислений. Если же термы не унифицируются, значит, никакая подстановка
      в дальнейшем не нарушит ограничение. Иначе необходимо запомнить унификатор в хранилище.
\item При встрече операции унификации $t_1 \equiv t_2$ необходимо получить их унификатор.
      Если его не существует или он пуст, то дополнительных действий производить не нужно.
	  Иначе нужно проверить, не нарушает ли унификатор ограничения неэквивалентности.
\end{itemize}

Указанное расширение было добавлено в библиотеку с реализацией сопуствующих алгоритмов.

Выявление остаточной программы по дереву процессов --- \emph{резидуализация} ---
породит новые опеределения отношений. Больше одного отношения из дерева процессов может
появиться в случае, когда узлы \lstinline{Renaming} указывают на узлы, отличные от корня.
Поэтому первой фазой происходит пометка узлов, задающих таким образом отношения,
а также удаление поддеревьев, у которых все ветви вычисления пришли к неудаче.

Далее происходит обход дерева, во время которого генерируются узлы синтаксического дерева программы
в зависимости от типа текущего узла дерева процессов:
\begin{itemize}
\item \lstinline{Unfoldable} узел приводит к появлению дизъюнкций подпрограмм, которые задают дети этого узла.
      Это обусловлено тем, что при прогонке в этом узле происходит ветвеление вычислений;
\item \lstinline{Abstraction} узел приводит к появлению конъюнкций подпрограмм, которые задают дети этого узла.
	  Это обусловлено тем, что хотя операция обобщения выявляет подконъюнкции из конфигурации и рассматривает их отдельно,
	  оба поддерева, задающиеся этими подконъюнкциями, должны выполнятся в одно и то же время;
\item \lstinline{Generalizer} задаёт обобщающий унификатор, который должен быть добавлен
      перед своим поддеревом;
\item \lstinline{Renaming} формирует вызов реляционного отношения;
\item \lstinline{Success} представляет собой успешное вычисление, предоставляющее непротиворечивую подстановку.
\end{itemize}
