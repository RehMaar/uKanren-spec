Реализация суперкомпилятора для \ukanren строилась на основе проекта по специализации \ukanren с помощью конъюнктивной частичной
дедукции\footnote{\url{https://github.com/kajigor/uKanren_transformations/}} на функциональном языке программирования Haskell.
Результаты специализации \ukanren представлены в работе~\cite{lozov}.

Библиотека вводит ряд структур данных и алгоритмов для реализации конъюнктивной частичной дедукции,
однако существует возможность её переиспользования для суперкомпиляции в силу нескольких доводов:
\begin{itemize}
\item схожесть методов частичной дедукции и суперкомпиляции\cite{pdAndDriving},
      из чего следует, что ряд вспомогательных функций и определений и для частичной дедукции, и для суперкомпиляции
      будут совпадать;
\item алгоритм обобщения конъюнктивной частичной дедукции\cite{cpd}, о котором подробнее будет рассказано позже,
      имеет ряд общих черт с шагами обобщения в суперкомпиляции;
\item библиотека предоставляет возможность преобразования сгенерированной программы
      на miniKanren, при котором удаляются излишние унификации и
      происходит удаление излишних аргументов~\origin{redundant argument filtering},
      что приводит в увличению производительности программы, поскольку унификация операция дорогая.
\end{itemize}

В библиотеке введены структуры данных, описывающие термы и выражения языка
в соответствии с синтаксисом \ukanren на рисунке~\ref{fig:syntax}.
Над ними введён ряд важных структур и алгоритмов, речь о которых пойдёт ниже.
Основные операции над выражениями в конъюнктивной частичной дедукции производятся над конъюнкциями
\emph{атомов}, --- то есть неделимыми элементами, которыми в miniKanren являются
вызовы реляционных отношений.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Унификация
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Во-первых, реализован алгоритм унификации двух термов.
Операция унификации находит наиболее общий унификатор \origin{most general unifier}, то есть такой
унификатор $\theta$, что для любого другого унификатора $\theta'$ существует подстановка $\sigma$,
с которой композиция наиболее общего унификатора даёт $\theta'$: $\theta' = \sigma \circ \theta$\cite{unification}.
К примеру, для двух термов $f(X, 2)$ и $f(1, Y)$ наиболее общим унификатором является
подстановка $\{ X \mapsto 1, Y \mapsto 2 \}$, когда подстановки вроде
$\{ X \mapsto 1, Y \mapsto Z, Z \mapsto 2 \}$ также унифицирует термы, однако
содержат в себе лишние элементы. Поиск наиболее общего унификатора уменьшает
размер итоговой подстановки и является предпочтительным.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Инстанс и вариант
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Во-вторых, реализованы предикаты над термами, которые проясняют описанные ниже возможные связи термов.
\begin{itemize}
\item Выражение $e_2$ является \emph{экземпляром} выражения $e_1$ ($e_2 \inst e_1$)
если существует такая подстановка $\theta$, применение которой приравнивает
два выражения $e_1 \theta = e_2$; также говорят, что $e_1$ более общий, чем $e_2$.
К примеру, $f(X, Y) \inst f(Y, X)$ и $f(X, Y) \inst f(Y, X)$ .
\item Выражение $e_2$ является \emph{строгим} экземпляром выражения $e_1$ ($e_2 \strictinst e_2$), если
$e_2 \inst e_1$ и $e_1 \not\inst e_2$. К примеру, $f(X, X) \strictinst f(X, Y)$, но не наоборот.
\item Выражения $e_1$ и $e_2$ \emph{варианты} друг друга, если они являются экземплярами друг друга.
\end{itemize}

Предикат над вариантами по своей сути определяет, являются ли два терма переименованием друг дурга,
и поэтому может быть использован для свёртки графа процессов. Предикаты над экземплярами определяют
схожесть термов и используется в обобщении и в алгроитмах суперкомпиляции~\cite{scPos}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Обобщение
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В-третьих, реализован алгоритм обобщения для конъюнктивной частичной дедукции.
В общем, алгоритмы обобщения основаны на понятии \emph{наиболее тесного обобщения}.
\emph{Обобщение} выражения $e_1$ и $e_2$ --- это выражение $e_g$, такое что
$e_g \inst e_1$  и $e_g \inst e_2$. На пример, обобщением выражения
$f(1, Y)$ и $f(X, 2)$ является $f(X, Y)$.
Наиболее тесное обобщение \origin{most specific generalization}
выражений $e_1$ и $e_2$ --- это обобщение $e_g$, такое что
для каждого обобщения $e_g' \inst e_1$ и $e_g' \inst e_2$ выполянется $e_g' \inst e_g$\cite{scPos}.
\todo{CPD gen и почему можем его использовать}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Свисток и гомеоморфное вложение
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В качестве свистка используется отношение \emph{гомеоморфного вложения}.\cite{scGen}
Отношение гомеоморфного вложения $\unlhd$ определено индуктивно:
\begin{itemize}
\item переменные вложены в переменные: $x \embed y$;
\item терм $X$ вложен в конструктор с именем $C$, если он вложен в один из аргументов конструктора:
      $$X \embed C_n(Y_1, \dots, Y_n): \exists i, X \embed Y_i;$$
\item конструкторы с одинаковыми именами состоят в отношении вложения, если в этом отношении
      состоят их аргументы:
      $$C_n(X_1, \dots, X_n) \embed C_n(Y_1, \dots, Y_n): \forall i, X_i \embed Y_i.$$
\end{itemize}

К примеру, выражение $c(b) \embed c(f(b))$, но $f(c(b)) \cancel{\embed} c(f(b))$.
Преимущество использования гомеоморфного вложения, в первую очередь, состоит в том,
что для этого отношения доказано, что на бесконечной последовательности выражений $e_0, e_1, \dots, e_n$
обязательно найдутся такие два индекса $i < j$, что $e_i \embed e_j$, вне зависимости
от того, каким образом последовательность выражений была получена~\cite{scPos}.
Это свойство повзоляет доказать завершаемость алгоритм суперкомпиляции.

Однако отношение гомеоморфного вложения допускает, чтобы термы $f(X, X)$ и $f(X, Y)$
находились в отношении гомеоморфного вложение $f(X, X) \embed f(X, Y)$ в силу того,
что все переменные вкладываются друг в друга. Однако в приведённом примере обобщение
$f(X, X)$ и $f(X, Y)$ не привело бы к более общей конфигурации.

Отношение \emph{строгого} гомеоморфного вложения $\embed^+$ вводит дополнительное
требование, чтобы терм $X$, состоящий в отношении с $Y$, не был \emph{строгим экземпляром} $Y$\cite{homeo}.
В таком случае отношение $f(X, X) \cancel{\embed}^+ f(X, Y)$, поскольку $f(X, Y)$ является строгим
экземпляром $f(X, X)$ из-за того, что существует подстановка $\{ X = X, Y = X \}$.

В рамках конъюнктивной частичной дедукции понятие гомеоморфного вложение было расширено на конъюнкции выражений.
Пусть $Q = A_1 \land \dots \land A_n$ и $Q'$ --- конъюнкции термов, тогда $Q \embed Q'$, тогда и только тогда,
когда $Q' \not\strictinst Q$ и существует упорядоченные подконъюнкции $A_1' \land \dots \land A_n'$
конъюнкции $Q'$ (то есть $Q'$ может содержать больше выражений, чем $Q$), такие что $A_i \embed A_i'$.
Конъюнкция $Q'$ может содержать в себе больше выражений за счёт того, что в этом случае при обобщении
произодёт шаг разделения.
